use crypto_bigint::{Encoding, NonZero, U256};
use secp256k1::{PublicKey, Scalar, Secp256k1};

use crate::crypto::{consts::{CIPHERTEXT_BYTES, SECRET_KEY_BYTES}, kem::{decaps, encaps}};

use super::v0::calculate_view_tag;

/// Recipient calculates shared secret and returns stealth public key 
/// 
/// ### Arguments 
/// * `k_pub` - recipient's public spending key, secp256k1 public key  
/// * `ephemeral_pub_key` - ephemeral public key generated by sender, post-quantum KEM ciphertext
/// * `v` - recipient's post-quantum KEM private viewing key 
/// ### Returns 
/// * `P` - stealth public key, secp256k1 public key
pub fn recipient_computes_stealth_pub_key(k_pub: &PublicKey, ephemeral_pub_key: &[u8; CIPHERTEXT_BYTES], v: &[u8; SECRET_KEY_BYTES]) -> PublicKey{
    // Calculate shared secret 
    let ss = decaps(ephemeral_pub_key, v);

    // Calculate stealth public key
    let stealth_pub_key = calculate_stealth_pub_key(&ss, k_pub); 

    stealth_pub_key
}

/// Sender calculates shared secret and returns stealth public key and view tag
/// 
/// ### Arguments 
/// * `k_pub` - recipient's public spending key, secp256k1 public key
/// * `v_pub` - recipient's public viewing key, post-quantum KEM public key
/// ### Returns 
/// * `P` - stealth public key, secp256k1 public key
/// * `R` - ephemeral public key, post-quantum KEM ciphertext
/// * `view_tag` - view tag , view tag is one byte of hash of shared secret 
pub fn sender_computes_stealth_pub_key_and_viewtag(v_pub: &[u8], k_pub: &PublicKey) -> (PublicKey, [u8; CIPHERTEXT_BYTES], u8){
    
    // Calculate shared secret and ciphertext used in KEM
    let (ephemeral_pub_key, ss) = encaps(v_pub);
   
    // Calculate stealth public key 
    let stealth_pub_key = calculate_stealth_pub_key(&ss, k_pub);

    // Calculate view tag by taking first byte of hash 
    let view_tag = calculate_view_tag(&ss);

    (stealth_pub_key, ephemeral_pub_key, view_tag)
}

/// Shared function to calculate stealth public key
/// 
/// ### Arguments 
/// * `ss` - shared secret, shared using post-quantum KEM
/// * `k_pub` - recipient's public spending key, secp256k1 public key
/// ### Returns 
/// 
/// * `P` - stealth public key, secp256k1 public key
pub fn calculate_stealth_pub_key(ss: &[u8; 32], k_pub: &PublicKey) -> PublicKey{
    let secp = Secp256k1::new(); 

    // convert shared secret from byte-slice to big integer
    let ss = U256::from_le_bytes(*ss);
    
    // secp256k1's prime
    let p = U256::from_be_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"); 
    
    // reduce modulo p 
    let ss = ss.rem(&NonZero::new(p).unwrap());

    // convert back to bytes 
    let ss = ss.to_be_bytes();

    // calculate stealth public key as ss*K 
    let stealth_pub_key = k_pub.mul_tweak(&secp, &Scalar::from_be_bytes(ss).expect("Error converting")).expect("Failed calculating stealth public key");

    stealth_pub_key
}
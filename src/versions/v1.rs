use crypto_bigint::{Encoding, NonZero, U256};
use ethers::abi::Address;
use secp256k1::{PublicKey, Scalar, Secp256k1, SecretKey};
use sha3::{Digest, Keccak256}; 

use crate::crypto::{consts::{CIPHERTEXT_BYTES, SECRET_KEY_BYTES}, kem::{decaps, encaps}};

use super::v0::calculate_view_tag;

/// Recipient calculates shared secret and returns stealth public key 
/// 
/// ### Arguments 
/// * `k_pub` - recipient's public spending key, secp256k1 public key  
/// * `ephemeral_pub_key` - ephemeral public key generated by sender, post-quantum KEM ciphertext
/// * `v` - recipient's post-quantum KEM private viewing key 
/// ### Returns 
/// * `P` - stealth public key, secp256k1 public key
pub fn recipient_computes_stealth_pub_key(k_pub: &PublicKey, ephemeral_pub_key: &[u8; CIPHERTEXT_BYTES], v: &[u8; SECRET_KEY_BYTES]) -> PublicKey{
    // Calculate shared secret 
    let ss = decaps(ephemeral_pub_key, v);

    // Calculate stealth public key
    let stealth_pub_key = calculate_stealth_pub_key(&ss, k_pub); 

    stealth_pub_key
}

/// Sender calculates shared secret and returns stealth public key and view tag
/// 
/// ### Arguments 
/// * `k_pub` - recipient's public spending key, secp256k1 public key
/// * `v_pub` - recipient's public viewing key, post-quantum KEM public key
/// ### Returns 
/// * `P` - stealth public key, secp256k1 public key
/// * `R` - ephemeral public key, post-quantum KEM ciphertext
/// * `view_tag` - view tag , view tag is one byte of hash of shared secret 
pub fn sender_computes_stealth_pub_key_and_viewtag(v_pub: &[u8], k_pub: &PublicKey) -> (PublicKey, [u8; CIPHERTEXT_BYTES], u8){
    
    // Calculate shared secret and ciphertext used in KEM
    let (ephemeral_pub_key, ss) = encaps(v_pub);
   
    // Calculate stealth public key 
    let stealth_pub_key = calculate_stealth_pub_key(&ss, k_pub);

    // Calculate view tag by taking first byte of hash 
    let view_tag = calculate_view_tag(&ss);

    (stealth_pub_key, ephemeral_pub_key, view_tag)
}

/// Shared function to calculate stealth public key
/// 
/// ### Arguments 
/// * `ss` - shared secret, shared using post-quantum KEM
/// * `k_pub` - recipient's public spending key, secp256k1 public key
/// ### Returns 
/// 
/// * `P` - stealth public key, secp256k1 public key
pub fn calculate_stealth_pub_key(ss: &[u8; 32], k_pub: &PublicKey) -> PublicKey{
    let secp = Secp256k1::new(); 

    // convert shared secret from byte-slice to big integer
    let ss = U256::from_le_bytes(*ss);
    
    // secp256k1's prime
    let p = U256::from_be_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"); 
    
    // reduce modulo p 
    let ss = ss.rem(&NonZero::new(p).unwrap());

    // convert back to bytes 
    let ss = ss.to_be_bytes();

    
    let s_scalar = Scalar::from_be_bytes(ss).expect("Error converting");
    let s_g = PublicKey::from_secret_key(&secp, 
        &SecretKey::from_slice(&s_scalar.to_be_bytes()).unwrap());
    
    // calculate stealth public key as K+s*G = (k+s)*G = K+S 
    k_pub.combine(&s_g).expect("Failed to add public keys")
}

/// Converts stealth public key that is `secp256k1`'s `PublicKey` to the  valid stealth address of type `Address`
/// 
/// ### Arguments 
/// * `stealth_pub_key` - Stealth public key of `secp256k1` curve
/// 
/// ### Returns 
/// * `stealth_address` - Valid stealth address 
pub fn stealth_pub_key_to_address(stealth_pub_key:&PublicKey) -> Address{
    // Takes last 20 bytes from the output of `Keccak256`
    let pub_bytes = stealth_pub_key.serialize_uncompressed();
    let hash = Keccak256::digest(&pub_bytes[1..]);
    let mut address_bytes = [0u8; 20];
    address_bytes.copy_from_slice(&hash[12..32]);
    let stealth_address = Address::from(&address_bytes); 
    
    stealth_address
}

/// Calculates stealth private key 
/// 
/// ### Arguments
/// * `s` - shared secret, a 32 byte array 
/// * `k` - `secp256k1`'s `SecretKey` 
/// 
/// ### Returns 
/// * `stealth_priv_key` - hex encoding of calculated stealth private key 
pub fn calculate_stealth_priv_key(s: &[u8; 32], k: &SecretKey) -> String{
    let s = U256::from_le_bytes(*s);
    let k = U256::from_be_bytes(k.secret_bytes());


    let p = U256::from_be_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"); 

    // reduce s mod p, where p is secp256k1's modulus p  
    let s = s.rem(&NonZero::new(p).unwrap());
   
    // stealth_priv_key = k+s
    let stealth_priv_key = k.add_mod(&s, &NonZero::new(p).unwrap());
 
   
    let stealth_priv_key = hex::encode(stealth_priv_key.to_be_bytes()); 

    stealth_priv_key 
}
#[cfg(any( feature = "kyber512", feature = "kyber768", feature = "kyber1024", not(any(feature = "kyber512",feature = "kyber768", feature = "kyber1024", feature = "newhope512",   feature = "newhope1024"))
))]
use pqc_kyber::{KYBER_K, KYBER_SYMBYTES, KYBER_POLYBYTES};
#[cfg(any( feature = "kyber512", feature = "kyber768", feature = "kyber1024", not(any(feature = "kyber512",feature = "kyber768", feature = "kyber1024", feature = "newhope512",   feature = "newhope1024"))
))]
use pqc_kyber::reference::{poly::poly_getnoise_eta1, indcpa::{gen_a, unpack_pk}, polyvec::{polyvec_add,polyvec_basemul_acc_montgomery, Polyvec, polyvec_reduce, polyvec_tobytes}, poly::poly_tomont};

use sha2::{Digest, Sha256};
use crate::crypto::consts::*;
use crate::crypto::kem::{decaps, encaps};
#[cfg(any(feature = "newhope1024", feature = "newhope512"))]
use crate::wrapper::newhope::rlwe_sample;


/// Recipient calculates shared secret and returns stealth public key 
/// 
/// ### Arguments 
/// * `k_pub` - recipient's public spending key 
/// * `ephemeral_pub_key` - ephemeral public key generated by sender 
/// * `v` - recipient's private viewing key 
/// ### Returns 
/// * `P` - stealth public key 
pub fn recipient_computes_stealth_pub_key(k_pub: &[u8; PUBLIC_KEY_BYTES], ephemeral_pub_key: &[u8; CIPHERTEXT_BYTES], v: &[u8; SECRET_KEY_BYTES]) -> [u8; STEALTH_ADDRESS_BYTES]{
    // Calculate shared secret 
    let ss = decaps(ephemeral_pub_key, v);

    // Calculate stealth public key 
    let stealth_pub_key = calculate_stealth_pub_key(&ss, k_pub); 
    
    stealth_pub_key
} 

/// Sender calculates shared secret and returns stealth public key and view tag
/// 
/// ### Arguments 
/// * `k_pub` - recipient's public spending key 
/// * `v_pub` - recipient's public viewing key
/// ### Returns 
/// * `P` - stealth public key 
/// * `R` - ephemeral public key
/// * `view_tag` - view tag 
pub fn sender_computes_stealth_pub_key_and_viewtag(v_pub: &[u8], k_pub: &[u8]) -> ([u8; STEALTH_ADDRESS_BYTES], [u8; CIPHERTEXT_BYTES], u8){
    assert!(v_pub.len() == PUBLIC_KEY_BYTES); 
    assert!(k_pub.len() == PUBLIC_KEY_BYTES); 
    
    // Calculate shared secret and ciphertext used in KEM
    let (ephemeral_pub_key, ss) = encaps(v_pub);
   
    // Calculate stealth public key 
    let stealth_pub_key = calculate_stealth_pub_key(&ss, k_pub);

    // Calculate view tag by taking first byte of hash 
    let view_tag = calculate_view_tag(&ss);

    (stealth_pub_key, ephemeral_pub_key, view_tag)
}

/// View tag calculation
/// 
/// ### Arguments 
/// * `ss` - shared secret
///
/// ### Returns 
/// * `view_tag` - view tag 
pub fn calculate_view_tag(ss: &[u8]) -> u8{
    assert!(ss.len() == SS_BYTES);

    // hash ss and return first byte
    let mut hasher = Sha256::new(); 
    hasher.update(ss);
    hasher.finalize()[0] 
}


/// Shared function to calculate stealth public key
/// 
/// ### Arguments 
/// * `ss` - shared secret
/// * `k_pub` - recipient's public spending key 
/// ### Returns 
/// 
/// * `P` - stealth public key 
pub fn calculate_stealth_pub_key(ss: &[u8], k_pub: &[u8]) -> [u8; STEALTH_ADDRESS_BYTES]{
    #[cfg(any( feature = "kyber512", feature = "kyber768", feature = "kyber1024", not(any(feature = "kyber512",feature = "kyber768", feature = "kyber1024", feature = "newhope512",   feature = "newhope1024"))
))]
    {
    // Get the encryption of spending key and seed used to derive matrix A
    let (mut pkpv, mut skpv)  = (Polyvec::new(), Polyvec::new());
    let mut public_seed = [0u8; KYBER_SYMBYTES];
    unpack_pk(&mut pkpv, &mut public_seed, k_pub);

    // derive matrix A 
    let mut a = [Polyvec::new(); KYBER_K];
    gen_a(&mut a, &public_seed); 
    
    // Convert shared secret to polynomial 
    let mut nonce = 0; 
    for i in 0..KYBER_K {
        poly_getnoise_eta1(&mut skpv.vec[i], &ss, nonce);
        nonce += 1;
    }
    

    // Compute A*S + K 
    let mut p_poly = Polyvec::new();
    for i in 0..KYBER_K{
        polyvec_basemul_acc_montgomery(&mut p_poly.vec[i], &a[i], &skpv);
        poly_tomont(&mut p_poly.vec[i]);
    }
    polyvec_add(&mut p_poly, &pkpv); 
    polyvec_reduce(&mut p_poly); 

    // Convert stealth public key from polynomial to bytes 
    let mut stealth_pub_key = [0u8; KYBER_K*KYBER_POLYBYTES];
    polyvec_tobytes(&mut stealth_pub_key, &p_poly);
    
    stealth_pub_key 
    }
    #[cfg(any(feature = "newhope1024", feature = "newhope512"))]
    rlwe_sample(k_pub, ss)
}

